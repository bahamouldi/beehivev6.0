input {
  beats {
    port => 5044
  }
}

filter {
  # Only process logs from beewaf_sklearn container
  if [container][name] != "beewaf_sklearn" {
    drop { }
  }
  
  # Drop Uvicorn access logs (INFO: ...) - keep only our JSON logs
  if [message] =~ "^INFO:" or [message] =~ "^\[" or [message] !~ "^\{" {
    drop { }
  }
  
  # Parse the JSON log from BeeWAF app contained in the message field
  if [message] {
    json {
      source => "message"
      skip_on_invalid_json => true
      target => "beewaf"
    }
  }
  
  # Move parsed fields to root level and rename 'event' to 'event_type' to avoid ECS conflict
  if [beewaf] {
    mutate {
      rename => { "[beewaf][event]" => "event_type" }
      rename => { "[beewaf][message]" => "log_message" }
      rename => { "[beewaf][client_ip]" => "client_ip" }
      rename => { "[beewaf][method]" => "http_method" }
      rename => { "[beewaf][path]" => "http_path" }
      rename => { "[beewaf][status_code]" => "status_code" }
      rename => { "[beewaf][reason]" => "block_reason" }
      rename => { "[beewaf][latency_ms]" => "latency_ms" }
      rename => { "[beewaf][body_preview]" => "body_preview" }
      rename => { "[beewaf][level]" => "log_level" }
      rename => { "[beewaf][service]" => "service" }
      rename => { "[beewaf][@timestamp]" => "app_timestamp" }
    }
    mutate {
      remove_field => [ "beewaf", "message" ]
    }
  }
  
  # Add service identifier if not present
  if ![service] {
    mutate {
      add_field => { "service" => "beewaf" }
    }
  }
  
  # Parse timestamp from our app's timestamp
  if [app_timestamp] {
    date {
      match => [ "app_timestamp", "ISO8601" ]
      target => "@timestamp"
    }
  }
  
  # Enrich blocked events
  if [event_type] == "blocked" {
    mutate {
      add_tag => [ "security", "blocked" ]
    }
    
    if [block_reason] == "regex-sqli" {
      mutate { add_field => { "attack_type" => "SQL Injection" } add_tag => [ "sqli" ] }
    } else if [block_reason] == "regex-xss" {
      mutate { add_field => { "attack_type" => "Cross-Site Scripting" } add_tag => [ "xss" ] }
    } else if [block_reason] == "regex-path-traversal" {
      mutate { add_field => { "attack_type" => "Path Traversal" } add_tag => [ "path-traversal" ] }
    } else if [block_reason] == "regex-cmd-injection" or [block_reason] == "regex-cmdi" {
      mutate { add_field => { "attack_type" => "Command Injection" } add_tag => [ "cmd-injection" ] }
    } else if [block_reason] == "rate-limit" {
      mutate { add_field => { "attack_type" => "Rate Limit Exceeded" } add_tag => [ "rate-limit" ] }
    } else if [block_reason] == "anomaly" {
      mutate { add_field => { "attack_type" => "ML Anomaly Detected" } add_tag => [ "anomaly", "ml" ] }
    }
  }
  
  # Add request count for aggregations
  if [event_type] == "request" or [event_type] == "blocked" {
    mutate {
      add_field => { "request_count" => 1 }
    }
  }
  
  # Clean up unnecessary Filebeat metadata
  mutate {
    remove_field => [ "agent", "ecs", "input", "log", "host", "event" ]
  }
}

output {
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "beewaf-logs-%{+YYYY.MM.dd}"
  }
}
